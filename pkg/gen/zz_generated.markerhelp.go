//go:build !ignore_autogenerated

/*
Copyright 2023 Alexandre Mahdhaoui.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by helpgen. DO NOT EDIT.

package gen

import (
	"sigs.k8s.io/controller-tools/pkg/markers"
)

func (ContainerGenerator) Help() *markers.DefinitionHelp {
	return &markers.DefinitionHelp{
		Category: "object",
		DetailedHelp: markers.DetailedHelp{
			Summary: "Conveniently generates a new Container ",
			Details: "Fields: \n - Name (string) identifies the container to be created. \n - Exported (optional bool) indicates if the Container should be exported or not. The Container is not exported by default.",
		},
		FieldHelp: map[string]markers.DetailedHelp{},
	}
}

func (ValueFuncGenerator) Help() *markers.DefinitionHelp {
	return &markers.DefinitionHelp{
		Category: "object",
		DetailedHelp: markers.DetailedHelp{
			Summary: "Creates a single func to conveniently access a di.Value. This marker is also used by the di-checker to create the dependency graph. ",
			Details: "Fields: \n - Name (string) identifies the func that will be used to access the defined value. \n - Container (optional string) specifies the di.Container's Name that will be used to store the Value. Container should always resolve to a di.Container defined in the current pkg. In other words, the \"consumer\" of a di.Value, defines both the di.Value and the di.Container in the same package where the di.Value is consumed. It's the job of the \"producer\" of the injectable value to import the ValueFunc from the getter package. In use cases where an interface is necessary to decouple \"consumer\" and the \"producer\", it is a best practice to create an \"interface package\" that defines both di.Value & di.Container, which can be imported by the \"consumers\" and the \"producers\" (!! Concurrent producers should NEVER be allowed: greatly reduce the side effects) \n - Type (string) defines the type T to the Value[T]. \n - TypeImport (optional string) defines package import for the specific type. \n - Exported indicates if the ValueFunc should be exported or not. The ValueFunc is exported by default.",
		},
		FieldHelp: map[string]markers.DetailedHelp{},
	}
}
